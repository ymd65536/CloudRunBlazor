@page "/chateval"
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@implements IDisposable
@using Microsoft.AspNetCore.Components.Web

<PageTitle>Chat Eval</PageTitle>

<div id="chat-container" class="chat-container">
    @foreach (var message in messages)
    {
        var messageClass = message.User == "You"
            ? "sent"
            : (message.User == "evaluator" ? "received evaluator"
                : (message.User == "System" ? "received system" : "received assistant"));
        var textClass = message.User == "evaluator" ? "chat-text eval" : "chat-text";
        var messageContent = message.User == "evaluator" ? ProcessColorTags(message.Text) : message.Text;
        <div class="chat-message @messageClass">
            <div class="message-content">
                @if (message.User != "You")
                {
                    <div class="chat-user">@message.User</div>
                }
                @if (message.User == "evaluator")
                {
                    <div class="@textClass">@((MarkupString)messageContent)</div>
                }
                else
                {
                    <div class="@textClass">@message.Text</div>
                }
            </div>
        </div>
    }
    @if (isProcessing)
    {
        <div class="chat-message received">
            <div class="message-content">
                <div class="chat-user">@(!isEvaluating ? "Assistant" : "evaluator")</div>
                <div class="chat-text">@(!isEvaluating ? "å…¥åŠ›ä¸­..." : "è©•ä¾¡ä¸­...")</div>
            </div>
        </div>
    }
</div>

<div class="chat-input">
    <input @ref="inputElement"
           @bind="newMessage" 
           @bind:event="oninput" 
           id="chat-input-field"
           placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..." 
           disabled="@isProcessing" />
    <button @onclick="SendMessage" disabled="@isProcessing">Send</button>
</div>

<script>
    window.setupChatInput = function(dotNetHelper) {
        const inputElement = document.getElementById('chat-input-field');
        if (!inputElement) return;
        
        let isComposing = false;
        
        inputElement.addEventListener('compositionstart', function() {
            isComposing = true;
        });
        
        inputElement.addEventListener('compositionend', function() {
            isComposing = false;
        });
        
        inputElement.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !isComposing) {
                e.preventDefault();
                dotNetHelper.invokeMethodAsync('SendMessageFromJS');
            }
        });
    };
</script>

@code {
    @using Azure.AI.OpenAI;
    @using Azure.Identity;
    @using Microsoft.Agents.AI;
    @using Microsoft.Extensions.AI;
    @using Microsoft.Extensions.AI.Evaluation;
    @using Microsoft.Extensions.Configuration;
    @using Microsoft.Extensions.AI.Evaluation.Quality;
    @using Microsoft.Extensions.AI.Evaluation.Reporting;
    @using Microsoft.Extensions.AI.Evaluation.Reporting.Storage;
    @using OpenAI;

    private List<Message> messages = new List<Message>();
    private string newMessage = string.Empty;
    private bool isProcessing = false;
    private bool isEvaluating = false;
    private ElementReference inputElement;
    private DotNetObjectReference<ChatEval>? dotNetHelper;
    private const string EvaluationSystemPrompt = "You are a helpful assistant for evaluation. Always respond in Japanese.";

    private string endpoint = Environment.GetEnvironmentVariable("AZURE_OPENAI_ENDPOINT")
        ?? throw new InvalidOperationException("Environment variable 'AZURE_OPENAI_ENDPOINT' is not set.");

    private string deploymentName = Environment.GetEnvironmentVariable("AZURE_OPENAI_DEPLOYMENT_NAME")
        ?? throw new InvalidOperationException("Environment variable 'AZURE_OPENAI_DEPLOYMENT_NAME' is not set.");

    private string summary = "";
    protected override void OnInitialized()
    {
        messages.Add(new Message { User = "Assistant", Text = "è©•ä¾¡ç”¨ãƒãƒ£ãƒƒãƒˆã¸ã‚ˆã†ã“ãã€‚ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦é€ä¿¡ã—ã¦ãã ã•ã„ã€‚" });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupChatInput", dotNetHelper);
            await ScrollToBottom();
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(newMessage) && !isProcessing)
        {
            var messageToSend = newMessage;
            newMessage = string.Empty; // Clear the input field immediately

            // Add user message
            messages.Add(new Message { User = "You", Text = messageToSend });

            // Set processing state and update UI
            isProcessing = true;
            StateHasChanged();

            // Give the DOM a moment to update before scrolling
            await Task.Delay(50);
            await ScrollToBottom();

            // Get AI response
            try
            {
                var aiResponse = await GetAIResponse(messageToSend);
                messages.Add(new Message { User = "Assistant", Text = aiResponse });

                // Assistant å¿œç­”ã‚’ä¸€æ—¦è¡¨ç¤ºã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                StateHasChanged();
                await Task.Delay(50);
                await ScrollToBottom();

                // Evaluate the assistant response and show the result in Japanese
                try
                {
                    isEvaluating = true;
                    StateHasChanged();
                    var evalSummary = await EvaluateResponse(EvaluationSystemPrompt, messageToSend, aiResponse);
                    messages.Add(new Message { User = "evaluator", Text = evalSummary });
                }
                catch (Exception evalEx)
                {
                    messages.Add(new Message { User = "System", Text = $"è©•ä¾¡æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {evalEx.Message}" });
                }
            }
            catch (Exception ex)
            {
                messages.Add(new Message { User = "System", Text = $"ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {ex.Message}" });
            }
            finally
            {
                isEvaluating = false;
                isProcessing = false;
                StateHasChanged(); // Important: Update UI to re-enable input
                await Task.Delay(50);
                await ScrollToBottom();
            }
        }
    }

    private async Task<string> GetAIResponse(string userMessage)
    {
        try
        {
            AIAgent agent = new AzureOpenAIClient(
                new Uri(endpoint),
                new DefaultAzureCredential())
                    .GetChatClient(deploymentName)
                    .CreateAIAgent(instructions: EvaluationSystemPrompt, name: "ChatEvalAssistant");

            ChatMessage systemMessage = new ChatMessage(
                ChatRole.System,
                EvaluationSystemPrompt);
            ChatMessage userChatMessage = new ChatMessage(ChatRole.User, userMessage);
            AgentRunResponse? result = await agent.RunAsync([systemMessage, userChatMessage]);

            return result?.ToString() ?? "å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“";
        }
        catch (Exception ex)
        {
            return $"ã‚¨ãƒ©ãƒ¼: {ex.Message}";
        }
    }

    private async Task<string> EvaluateResponse(string chatSystemMessage, string userMessage, string aiResponse)
    {
        // æ¯å›æ–°ã—ã„è¦ç´„ã‚’ä½œæˆ
        summary = string.Empty;

        IEvaluator[] evaluators = [
            new CoherenceEvaluator(),
            new FluencyEvaluator(),
            new RelevanceEvaluator(),
        ];

        AzureOpenAIClient chatClient =
            new(
                new Uri(endpoint),
                new DefaultAzureCredential(new DefaultAzureCredentialOptions()));

        IChatClient client = chatClient.GetChatClient(deploymentName: deploymentName).AsIChatClient();

        var chatConfig = new ChatConfiguration(client);

        // ãƒ‡ã‚£ã‚¹ã‚¯ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿å­˜ã™ã‚‹ ReportingConfiguration ã‚’ä½œæˆ
        var reportingConfiguration = DiskBasedReportingConfiguration.Create(
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿å­˜ã™ã‚‹ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
            storageRootPath: "./reports",
            // è©•ä¾¡å™¨ã®è¨­å®š
            evaluators,
            chatConfig
            );

        // ReportingConfiguration ã‚’ä½¿ã£ã¦ ScenarioRun ã‚’ä½œæˆ (ScenarioRun ã‚’ä½¿ã£ã¦å®Ÿéš›ã®è©•ä¾¡ã‚’è¡Œã†ï¼‰
        ScenarioRun scenario = await reportingConfiguration.CreateScenarioRunAsync("QualityEvaluators");
        // ã‚¤ãƒ³ãƒ—ãƒƒãƒˆã«å¯¾ã—ã¦ã€çµæœãŒã¡ã‚ƒã‚“ã¨ã—ã¦ã„ã‚‹ã‹ã‚’è©•ä¾¡
        EvaluationResult evaluationResult = await scenario.EvaluateAsync(
            // ãƒãƒ£ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ—ãƒƒãƒˆ
            [
                new ChatMessage(ChatRole.System, chatSystemMessage),
                new ChatMessage(ChatRole.User, userMessage),
            ],
            // çµæœ
            new ChatResponse(new ChatMessage(ChatRole.Assistant, aiResponse))
        );
        
        // è©•ä¾¡ã‚µãƒãƒªãƒ¼ã®ãƒ˜ãƒƒãƒ€ãƒ¼
        summary = "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n";
        summary += "ğŸ“Š å“è³ªè©•ä¾¡ãƒ¬ãƒãƒ¼ãƒˆ\n";
        summary += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n";
        
        int metricNumber = 1;
        foreach (var metric in evaluationResult.Metrics)
        {
            // EvaluationMetric ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç¢ºèª
            if (metric.Value is EvaluationMetric evalMetric)
            {
                // ãƒ¡ãƒˆãƒªãƒƒã‚¯åã«å¿œã˜ãŸçµµæ–‡å­—ã¨ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
                var metricEmoji = GetMetricEmoji(evalMetric.Name ?? metric.Key);
                var metricColor = GetMetricColorTag(evalMetric.Name ?? metric.Key);
                
                summary += $"\n{metricColor}{metricEmoji} è©•ä¾¡é …ç›® {metricNumber}: {evalMetric.Name ?? metric.Key}{{/color}}\n";
                summary += new string('â”€', 40) + "\n";
                
                // ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼ˆæ•°å€¤ã®å ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼é¢¨ã«ï¼‰
                if (evalMetric.Interpretation != null)
                {
                    var interpretationText = evalMetric.Interpretation.ToString() ?? string.Empty;
                    var scoreBar = TryExtractScoreAndCreateBar(interpretationText, out var displayText);
                    
                    summary += $"â–¸ ğŸ“Š è©•ä¾¡çµæœ\n  {displayText}";
                    if (!string.IsNullOrWhiteSpace(scoreBar))
                    {
                        summary += $"\n  {scoreBar}";
                    }
                    summary += "\n\n";
                }
                
                if (!string.IsNullOrWhiteSpace(evalMetric.Reason))
                {
                    summary += $"â–¸ ğŸ’¡ ç†ç”±\n  {evalMetric.Reason}\n\n";
                }
                
                if (evalMetric.Context != null && evalMetric.Context.Count > 0)
                {
                    summary += $"â–¸ ğŸ“ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ\n";
                    foreach (var ctx in evalMetric.Context)
                    {
                        summary += $"  â€¢ {ctx.Key}: {ctx.Value}\n";
                    }
                    summary += "\n";
                }
                
                // Diagnostics ã®è©³ç´°ã‚’ç¢ºèª
                if (evalMetric.Diagnostics != null && evalMetric.Diagnostics.Count > 0)
                {
                    summary += $"â–¸ ğŸ” è¨ºæ–­æƒ…å ± ({evalMetric.Diagnostics.Count}ä»¶)\n";
                    foreach (var diagnostic in evalMetric.Diagnostics)
                    {
                        summary += $"  â€¢ {diagnostic.Message} [é‡è¦åº¦: {diagnostic.Severity}]\n";
                    }
                    summary += "\n";
                }
                
                // Metadata ã®ç¢ºèª
                if (evalMetric.Metadata != null && evalMetric.Metadata.Count > 0)
                {
                    summary += $"â–¸ ğŸ”– è©³ç´°æƒ…å ± ({evalMetric.Metadata.Count}é …ç›®)\n";
                    foreach (var meta in evalMetric.Metadata)
                    {
                        summary += $"  â€¢ {meta.Key}: {meta.Value}\n";
                    }
                    summary += "\n";
                }
                
                metricNumber++;
            }
        }
        
        summary += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”";

        // ç¿»è¨³ã—ã¦æ—¥æœ¬èªã§è¿”ã™ï¼ˆãƒ©ãƒ™ãƒ«ã¯æ—¥æœ¬èªåŒ–æ¸ˆã¿ã ãŒã€æœ¬ä½“ãŒè‹±èªã®å ´åˆã«å‚™ãˆã‚‹ï¼‰
        try
        {
            var translated = await TranslateToJapanese(summary);
            var finalText = string.IsNullOrWhiteSpace(translated) ? summary : translated;
            return finalText.Trim();
        }
        catch
        {
            return summary.Trim();
        }
    }

    private async Task<string> TranslateToJapanese(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return text;

        try
        {
            var client = new AzureOpenAIClient(new Uri(endpoint), new DefaultAzureCredential());
            var agent = client
                .GetChatClient(deploymentName)
                .CreateAIAgent(
                    instructions: @"You are a professional Japanese translator specialized in technical evaluation reports.
- Translate all content into natural, professional Japanese.
- Keep ALL formatting: line breaks, indentation, bullets (â€¢), section markers (â–¸, â—†), emoji, and decorative lines (â”, â”€).
- Preserve technical terms appropriately (e.g., 'Coherence' â†’ 'ä¸€è²«æ€§', 'Fluency' â†’ 'æµæš¢æ€§', 'Relevance' â†’ 'é–¢é€£æ€§').
- Keep color tags like {color:blue} intact.
- Translate evaluation content while maintaining clarity and professionalism.
- Output ONLY the translated text without any explanations.",
                    name: "Translator");

            var system = new ChatMessage(ChatRole.System, @"You translate technical evaluation reports into natural Japanese. 
Preserve all formatting elements: emoji, bullets, lines, indentation, color tags. 
Translate technical terms appropriately while keeping the report structure intact.");
            var user = new ChatMessage(ChatRole.User, text);
            var result = await agent.RunAsync([system, user]);
            return result?.ToString() ?? text;
        }
        catch
        {
            return text;
        }
    }

    private string GetMetricEmoji(string metricName)
    {
        if (string.IsNullOrEmpty(metricName)) return "ğŸ“Œ";
        
        var name = metricName.ToLower();
        return name switch
        {
            var n when n.Contains("coherence") || n.Contains("ä¸€è²«") => "ğŸ”—",
            var n when n.Contains("fluency") || n.Contains("æµæš¢") => "âœ¨",
            var n when n.Contains("relevance") || n.Contains("é–¢é€£") => "ğŸ¯",
            var n when n.Contains("groundedness") || n.Contains("æ ¹æ‹ ") => "ğŸ›ï¸",
            var n when n.Contains("similarity") || n.Contains("é¡ä¼¼") => "ğŸ”„",
            var n when n.Contains("correctness") || n.Contains("æ­£ç¢º") => "âœ…",
            _ => "ğŸ“Œ"
        };
    }

    private string GetMetricColorTag(string metricName)
    {
        if (string.IsNullOrEmpty(metricName)) return "{color:gray}";
        
        var name = metricName.ToLower();
        var colorName = name switch
        {
            var n when n.Contains("coherence") || n.Contains("ä¸€è²«") => "blue",
            var n when n.Contains("fluency") || n.Contains("æµæš¢") => "green",
            var n when n.Contains("relevance") || n.Contains("é–¢é€£") => "purple",
            var n when n.Contains("groundedness") || n.Contains("æ ¹æ‹ ") => "orange",
            var n when n.Contains("similarity") || n.Contains("é¡ä¼¼") => "cyan",
            var n when n.Contains("correctness") || n.Contains("æ­£ç¢º") => "teal",
            _ => "gray"
        };
        return $"{{color:{colorName}}}";
    }

    private string TryExtractScoreAndCreateBar(string interpretationText, out string displayText)
    {
        displayText = interpretationText;
        
        // ã‚¹ã‚³ã‚¢ã®æŠ½å‡ºã‚’è©¦ã¿ã‚‹ï¼ˆä¾‹: "Score: 4", "4/5", "80%", "0.8" ãªã©ï¼‰
        var scorePatterns = new[]
        {
            @"(?:score|ã‚¹ã‚³ã‚¢)[:\s]*(\d+(?:\.\d+)?)\s*(?:/\s*(\d+))?",
            @"(\d+)%",
            @"^(\d+(?:\.\d+)?)\s*/\s*(\d+)$",
            @"^0?\.(\d+)$"
        };

        foreach (var pattern in scorePatterns)
        {
            var match = System.Text.RegularExpressions.Regex.Match(interpretationText, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            if (match.Success)
            {
                double score;
                double maxScore = 5.0;

                if (match.Groups.Count > 2 && !string.IsNullOrEmpty(match.Groups[2].Value))
                {
                    // "4/5" å½¢å¼
                    score = double.Parse(match.Groups[1].Value);
                    maxScore = double.Parse(match.Groups[2].Value);
                }
                else if (pattern.Contains("%"))
                {
                    // "80%" å½¢å¼
                    score = double.Parse(match.Groups[1].Value);
                    maxScore = 100.0;
                }
                else if (pattern.Contains("0?\\."))
                {
                    // "0.8" å½¢å¼
                    score = double.Parse("0." + match.Groups[1].Value);
                    maxScore = 1.0;
                }
                else
                {
                    score = double.Parse(match.Groups[1].Value);
                }

                // æ­£è¦åŒ–ï¼ˆ0-1ã®ç¯„å›²ã«ï¼‰
                var normalized = score / maxScore;
                return CreateProgressBar(normalized, score, maxScore);
            }
        }

        return string.Empty;
    }

    private string CreateProgressBar(double normalizedScore, double score, double maxScore)
    {
        const int barLength = 20;
        var filledLength = (int)(normalizedScore * barLength);
        var emptyLength = barLength - filledLength;

        var bar = new string('â–ˆ', filledLength) + new string('â–‘', emptyLength);
        var percentage = (normalizedScore * 100).ToString("F1");
        
        return $"[{bar}] {percentage}% ({score}/{maxScore})";
    }

    private string ProcessColorTags(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;
        
        // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        text = System.Net.WebUtility.HtmlEncode(text);
        
        // ã‚«ãƒ©ãƒ¼ã‚¿ã‚°ã‚’å‡¦ç†
        var colorMap = new Dictionary<string, string>
        {
            { "blue", "#2563eb" },
            { "green", "#16a34a" },
            { "purple", "#9333ea" },
            { "orange", "#ea580c" },
            { "cyan", "#0891b2" },
            { "teal", "#0d9488" },
            { "gray", "#6b7280" }
        };
        
        foreach (var (colorName, colorCode) in colorMap)
        {
            text = text.Replace($"{{color:{colorName}}}", $"<span style='color:{colorCode};font-weight:600;'>");
        }
        text = text.Replace("{/color}", "</span>");
        
        // æ”¹è¡Œã‚’HTMLã®æ”¹è¡Œã«å¤‰æ›
        text = text.Replace("\n", "<br/>");
        
        return text;
    }

    [JSInvokable]
    public async Task SendMessageFromJS()
    {
        await SendMessage();
    }

    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", "var el = document.getElementById('chat-container'); if(el) { el.scrollTop = el.scrollHeight; }");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error scrolling to bottom: {ex.Message}");
        }
    }

    private class Message
    {
        public string User { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
    }
}